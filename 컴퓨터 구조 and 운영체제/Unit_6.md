# 6단원 - 메모리와 캐시 메모리

- 주기억 장치의 종류
    - RAM (메모리라는 용어는 이걸 지칭하는 경우가 많음)
    - ROM

<br>
<br>
<br>

## RAM의 특징과 종류

- **RAM**

→ 실행할 프로그램의 명령어와 데이터 저장. 

<ins>전원을 끄면 RAM에 저장된 명령어와 데이터가 모두 날아감 (휘발성 저장장치)</ins>

<br>
<br>

- <ins>휘발성 저장장치</ins>

→ 전원을 끄면 저장된 내용이 사라지는 저장 장치

<br>

- <ins>비휘발성 저장장치</ins>

→ 전원이 꺼져도 저장된 내용이 유지되는 저장 장치

(ex: 하드디스크, SSD, CD-ROM, USB메모리 ⇒ 보조기억장치들)

<br>

보조기억장치는 전원을 꺼도 내용 유지

CPU는 보조기억장치에 직접 접근 못함

<br>

<ins>보조기억장치인</ins> 비휘발성 저장 장치에는 <ins>‘보관할 대상’</ins>을 저장

휘발성 저장 장치인 <ins>RAM</ins>에는 <ins>‘실행할 대상’</ins>을 저장

⇒ CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 이를 RAM으로 복사하여 저장한 뒤 실행

<br>

<ins>RAM용량이 적으면</ins> 보조기억장치에서 실행할 프로그램을 가져오는 일이 잦아 실행 시간이 길어짐

<ins>RAM용량이 크면</ins> 보조기억장치에서 많은 데이터를 가져와 미리 RAM에 저장할 수 있다 

⇒ 많은 프로그램을 동시에 실행하는 데 유리하고, 프로그램들을 보조기억장치에서 여러 번 가져오는 수고를 덜 수 있다.

<br>

RAM용량이 필요 이상으로 커졌을 때 속도가 그에 비례하여 증가하지는 않는다.

<br>
<br>

### RAM의 종류

- **DRAM (Dynamic RAM)**
    - 시간이 지나면 저장된 데이터가 동적으로 변하는 (사라지는) RAM
    - 데이터의 소멸을 막기 위해 일정 주기로 데이터를 재활성화 (다시저장) 해야 함.
    - 소비전력이 비교적 낮고, 저렴, 집적도 높기(더 작고 빽빽하게 만들 수 있다) 때문에 대용량으로 설계하기 용이
    - 일반적으로 메모리로써 사용하는 RAM (주기억장치로 사용)
- **SRAM (Static RAM)**
    - 시간이 지나도 저장된 데이터가 사라지지 않는다
    - SRAM보다 일반적으로 속도가 더 빠르다
    - 집적도 낮고, 소비전력 크고, 가격이 비싸다 → 대용량으로 만들어질 필요는 없지만 속도가 빨라야하는 저장 장치(⇒ 캐시 메모리) 에 사용
- **SDRAM (Synchronous Dynamic RAM, SDR SDRAM)**
    - 클럭에 맞춰 동작하며 클럭마다 CPU와 정보를 주고받을 수 있는 DRAM (클럭과 동기화된 DRAM)
- **DDR SERAM (Double Data Rate SERAM)**
    - 가장흔히 사용되는 RAM
    - 대역폭을 넓혀 속도를 빠르게 만든 SERAM (대역폭: 데이터를 주고받는 길의 너비)
    - SDRAM에 비해 두배의 대역폭으로 한클럭당 두 번씩 CPU와 데이터를 주고받을 수 있다. (SDR SERAM에 비해 대역폭이 두 배 넓은 SDRAM)
    - 전송속도도 두 배 가량 빠르다
    - +) DDR2 SDRAM: DDR SDRAM보다 대역폭이 두 배 넓은 SDRAM
    - +) DDR3 SDRAM는 4배, DDR4 SDRAM는 8배 DDR SDRAM 보다 넓다. (최근에 흔히 사용하는 메모리는 DDR4 SDRAM. SDR SDRAM보다 16배 넓은 대역폭)

<br>

|  | DRAM | SRAM |
| --- | --- | --- |
| 재충전 | 필요함 | 필요 없음 |
| 속도 | 느림 | 빠름 |
| 가격 | 저렴함 | 비쌈 |
| 집적도 | 높음 | 낮음 |
| 소비전력 | 적음 | 높음 |
| 사용 용도 | 주기억장치 (RAM) | 캐시 메모리 |

<br>
<br>
<br>

## 메모리의 주소 공간

메모리에 저장된 정보는 시시각각 변하기 때문에 CPU와 메모리에 저장되어 실행 중인 프로그램은 메모리 몇 번지에 무엇이 저장되어있는지 다 알지 못한다.

<br>

- **물리 주소**

→ (정보가 실제로 저장된) 메모리 하드웨어상의 주소

메모리가 사용하는 주소

<br>

- **논리 주소**

→ CPU와 실행 중인 프로그램이 사용하는 주소

실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소

프로그램마다 같은 논리 주소가 있을 수 있다.

CPU는 이 논리주소를 받아들이고, 해석하고, 연산한다.

![논리주소와 물리주소](6단원%20-%20논리주소와%20물리주소.png)

<br>

- **메모리 관리 장치 (MMU)**

→ 논리 주소를 물리 주소로 변환하는 장치 (하드웨어)

CPU가 메모리와 상호작용하기위해서는 논리 주소와 물리 주소 간의 변환이 이루어져야 한다.

CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더해 논리 주소를 물리 주소로 변환한다.

<br>

<ins>베이스 레지스터</ins>: 프로그램의 가장 작은 물리 주소. 프로그램의 첫 물리 주소 저장

<ins>논리주소</ins>: 프로그램의 시작점으로부터 떨어진 거리

![MMU](6단원%20-%20MMU.png)

<br>
<br>

- **한계 레지스터 (메모리 보호 기법)**

→ 실행 중인 프로그램의 논리 주소의 최대 크기를 저장 (for 메모리 보호)

논리 주소 범위를 벗어나는 명령어 실행을 방지하고 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 보호하는 방법.

한계 레지스터 값을 넘어서는 논리 주소를 가질 수 없다.

한계 레지스터 값보다 높은 주소에 접근하려고하면 인터럽트(트랩)을 발생시켜 실행 중지

<br>

<ins>베이스 레지스터값 ≤ 프로그램의 물리 주소 범위 < 베이스 레지스터 값 + 한계 레지스터 값</ins>

한계 레지스터 = 프로그램의 물리 주소 범위 = 프로그램의 크기

<br>
<br>
<br>

## 캐시 메모리

<br>

- 저장장치가 따르는 명제
    1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다
    2. 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.

⇒ 컴퓨터는 다양한 저장 장치를 모두 사용하게 된다.

<br>

- **저장 장치 계층 구조**

→ 각기 다른 용량과 성능의 저장 장치들을 계층화하여 표현한 구조 (CPU에 얼마나 가까운가를 기준으로)

위로갈수록 CPU에 가까운 저장장치

![저장장치 계층구조](6단원%20-%20저장장치%20계층구조.png)

<br>
<br>

- **캐시 메모리**

→ CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위한 저장 장치

CPU와 메모리 사이에 위치

레지스터보다 용량이 크고 메모리보다 빠른 SRAM기반의 저장 장치

메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가지고 와서 활용.

<br>

캐시 메모리도 CPU(코어)와 가까운 순서대로 계층을 구성

가까운 순서대로 L1캐시, L2캐시, L3캐시 (1, 2는 내부에, 3은 외부에)

메모리의 용량: 1 < 2 < 3

속도: 3 < 2 < 1

가격: 3< 2 < 1

메모리 탐색: L1 → L2 → L3

L1, L2 캐시는 코어마다 고유한 캐시메모리로 할당. L3 캐시는 여러 코어가 공유하는 형태로 사용

캐시 메모리는 메모리보다 용량이 작다.

<br>

+) 분리형 캐시

코어와 가장 가까운 L1 캐시는 조금이라도 접근 속도를 빠르게 만들기 위해 캐시를 둘로 분리했다.

L1I: 명령어만을 저장

L1D: 데이터만을 저장

<br>
<br>

캐시 히트: 캐시 메모리는 CPU가 사용할 법한 대상을 예측하여 저장한다. 이때 자주 사용될 것으로 예측한 데이터가 실제로 들어맞아 캐시 메모리 내 데이터가 CPU에서 활용될 경우.

캐시 미스: 예측이 틀려 메모리에서 필요한 데이터를 직접 가져와야 하는 경우. (CPU가 필요한 데이터를 메모리에서 직접 가지고와야한다. 자주 발생하면 성능이 떨어짐)

![캐시 메모리](6단원%20-%20캐시%20메모리.png)

캐시 적중률 = 캐시 히트 횟수 / (캐시 히트 횟수 + 캐시 미스 횟수)

캐시 적중률이 높으면 CPU의 메모리 접근 횟수를 줄일 수 있다.

보통의 컴퓨터의 캐시 적중률: 85~95%이상

<br>
<br>

- **참조 지역성의 원리**

→ CPU가 메모리에 접근할 때의 주된 경향을 바탕으로 만들어진 원리

1. CPU가 최근에 접근했던 메모리 공간에 다시 접근하려는 경향 (시간 지역성 / ex: 변수)
2. CPU가 접근한 메모리 공간 근처를 접근하려는 경향 (공간 지역성)

→ CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 모여있다. 따라서 프로그램을 실행할때 그 프로그램이 모여있는 공간 근처를 집중적으로 접근할 것이기 때문