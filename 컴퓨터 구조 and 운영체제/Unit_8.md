# 8단원 - 입출력장치

## 장치 컨트롤러와 장치 드라이버

- **장치 컨트롤러(= 입출력 제어기 = 입출력 모듈)**

→ 입출력장치와 CPU사이의 통신을 중개하는 장치

<br>

<ins>입출력 장치가 장치 컨트롤러를 통해 연결되는 이유</ins>

1. 입출력장치 종류가 많다 ⇒ 입출력장치와 정보를 주고받는 방식을 규격화하기 어렵다
2. CPU와 메모리의 데이터 전송률을 높지만 입출력장치의 데이터 전송률은 낮다 ⇒ 전송률의 차이가 CPU와 메모리, 입출력장치 간의 통신을 어렵게 한다.

+) <ins>전송률</ins>: 데이터를 얼마나 빨리 교환할 수 있는지를 나타낼 수 있는 지표

<br>

<ins>장치 컨트롤러의 역할</ins>

- CPU와 입출력장치 간의 통신 중개 → 정보 규격화가 어려웠던 문제 해결
- 오류검출 → 입출력장치에 문제 없는지 오류 검출
- 데이터 버퍼링 → CPU와 입출력장치와의 전송률 차이 완화

+) <ins>버퍼링</ins>: 전송률이 높은 장치와 낮은 장치 사이에 주고받는 데이터를 버퍼라는 임시 저장 공간에 저장하여 전송률을 비슷하게 맞추는 방법

→ 버퍼에 데이터를 조금씩 모았다가 한꺼번에 내보내거나 데이터를 한번에 많이 받아 조금씩 내보내는 방법

<br>

- <ins>내부 구조</ins>
    - 데이터 레지스터: CPU와 입출력장치 사이에 주고받을 데이턱 담기는 레지스터. 버퍼역할한다. (주고받는 데이터가 많으면 RAM을 사용하기도 한다)
    - 상태 레지스터: 입출력장치의 상태정보 저장
    - 제어 레지스터: 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장

⇒ 레지스터들에 담긴 값들은 CPU나 다른 입출력 장치로 전달 되거나 장치 컨트롤러에 연결된 입출력장치로 전달

<br>
<br>

- **장치 드라이버**

→ 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램

새로운 장치를 컴퓨터에 연결하려면 장치드라이버를 설치해야한다.

장치 컨트롤러의 동작을 감지하고 제어

프로그램이라 실행 과정에서 메모리에 저장.

입출력장치를 연결하기 위한 소프트웨어적인 통로.

<br>
<br>
<br>

## 다양한 입출력 방법

### 프로그램 입출력

→ 프로그램 속 명령어로 입출력 작업 (입출력장치를 제어)을 하는 방식

1. CPU가 컨트롤러 제어 레지스터에 명령을 보낸다
2. 입출력장치가 컨트롤러의 상태 레지스터에 자신의 상태를 보낸다.
3. CPU는 상태 레지스터를 주기적으로 읽어본다. 상태 레지스터로 입출력장치가 준비 됐음을 확인하면, 제어 레지스터의 명령에 필요한 데이터를 데이터 레지스터에 보내 입출력장치에 데이터를 가지고 명령을 수행한다.

<br>
<br>

- **메모리 맵 입출력**

→ 메모리에 접근하기 위한 주소 공간과 입출력장치에 접근하기 위한 주소 공간을 하나의 주소 공간으로 간주하는 입출력 방식

⇒ CPU는 메모리의 주소들이나 장치 컨트롤러의 레지스터들이나 모두 똑같이 메모리 주소를 대하듯 하면 된다. (메모리에 접근하는 명령어와 입출력장치에 접근하는 명령어는 굳이 다를 필요가 없다.)

가지고있는 전체 메모리 주소중 반은 메모리를 위한 주소 공간으로, 반은 입출력장치를 위한 주소 공간으로 사용한다.

<br>

- **고립형 입출력**

→ 메모리에 접근하기 위한 주소 공간과 입출력 장치에 접근하기 위한 주소 공간을 별도의 주소 공간으로 분리하는 입출력 방식

CPU는 입출력장치에 접근하기 위해 메모리에 접근하는 명령어와는 다른 입출력 명령어를 사용한다.

![입출력 종류](8단원%20-%20고립형%20입출력.png)

| 메모리 맵 입출력 | 고립형 입출력 |
| --- | --- |
| 메모리와 입출력장치는 같은 주소 공간 사용 | 메모리와 입출력장치는 분리된 주소 공간 사용 |
| 메모리 주소 공간이 축소됨 | 메모리 주소 공간이 축소되지 않음 |
| 메모리와 입출력장치에 같은 명령어 사용 가능 | 입출력 전용 명령어 사용 |

<br>
<br>
### **인터럽트 기반 입출력**

→ 인터럽트로써 입출력을 수행하는 방법

입출력장치에 의한 하드웨어 인터럽트는 장치 컨트롤러에 의해 발생한다.

CPU가 장치 컨트롤러에게 입출력 명령을 하고 장치 컨트롤러가 입출력 장치를 제어하며 입출력을 수행하는 동안 CPU는 다른 일을 한다.

장치 컨트롤러가 입출력 작업을 끝낸 뒤 CPU에게 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업하고 인터럽트 서비스 루틴을 실행한다.

<br>

+) <ins>폴링</ins>: 입출력장치의 상태는 어떤지, 처리할 데이터가 있는지 주기적으로 확인하는 방식.

인터럽트 방식보다 CPU의 부담이 더 크다.

<br>
<br>

- 인터럽트 처리 방식
    1. 인터럽트가 발생한 순서대로 인터럽트를 처리하는 방법.
    2. 인터럽트간의 우선순위를 고려하여 우선순위가 높은 인터럽트 순으로 처리

<br>

+) <ins>NMI (Non-Maskable Interrupt)</ins>: 인터럽트 비트를 비활성화해도 무시할 수 없는 인터럽트

<ins>프로그래머블 인터럽트 컨트롤러 (PIC)</ins>: 여러장치 컨트롤러에 연결, 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들의 우선순위를 판별한 뒤 CPU에 지금 처리해야 할 하드웨어 인터럽트는 무엇인지 알려주는 장치

<br>

- PIC의 다중 인터럽트 처리과정
    1. 장치 컨트롤러에서 인터럽트 요청 신호(들)를 받아들인다
    2. 인터럽트 우선순위를 판단한 뒤 CPU에 처리해야 할 인터럽트 요청 신호를 보낸다.
    3. CPU는 PIC에 인터럽트 확인 신호를 보낸다
    4. PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다
    5. CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게 되고, 해당 장치의 인터럽트 서비스 루틴을 실행.

<br>

일반적으로는 PIC를 두 개 이상 계층적으로 구성

PIC는 NMI까지 우선순위를 판별하지는 않는다. 비트를 통해 막을 수 있는 하드웨어 인터럽트만 우선순위를 조정해준다.

<br>
<br>

<ins>프로그램 기반 입출력과 인터럽트 기반 입출력에 공통점</ins>이 있다면 입출력 장치와 메모리 간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다는 점.

<br>

- **DMA입출력**

→ <ins>CPU를 거치지 않고</ins> 메모리와 입출력장치 간에 데이터를 주고받는 입출력 방법

(직접 메모리에 접근할 수 있는 입출력 기능)

DMA 컨트롤러 필요

<br>

- 과정
    1. CPU는 DMA컨트롤러에 입출력장치의 주소, 수행할 연산 (읽기/쓰기), 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령
    2. DMA 컨트롤러는 CPU 대신 장치 컨트롤러와 상호작용하며 작업 수행. DMA 컨트롤러는 필요한 경우 메모리에 직접 접근하여 정보를 읽거나 쓴다.
    3. 작업이 끝나면 DMA컨트롤러는 CPU에 인터럽트를 걸어 작업이 끝났음을 알린다.

⇒ CPU는 입출력의 시작과 끝에만 관여

<br>
<br>

but. <ins>시스템 버스는 동시 사용이 불가하다</ins>

⇒ DMA컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마나다 조금씩 시스템 버스를 이용 or 일시적으로 시스템 버스를 이용하지 않도록 허락을 구하고 시스템 버스를 집중적으로 이용 (사이클 스틸링)

<br>

- **입출력 버스**

→ 입출력장치와 컴퓨터 내부를 연결 짓는 통로. 입출력 작업의 시스템 버스 사용 횟수를 줄인다.

(DMA 컨트롤러와 장치 컨트롤러들이 연결)

ex) PCI버스, PCI Express (PCIe)버스 (PCIe슬롯: 여러입출력장치들을 PCIe버스와 연결해주는 통로)

<br>
<br>

+) 입출력 전용 CPU: 입출력 프로세서, 입출력 채널

→ 메모리에 직접 접근, 입출력 명령어를 직접 인출, 해석, 실행까지 한다.