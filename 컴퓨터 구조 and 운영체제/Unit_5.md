# 5단원 - CPU 성능 향상 기법

## 빠른 CPU를 위한 설계 기법

⇒ 클럭 속도를 높인다. CPU의 코어와 스레드 수를 늘린다.

<br>

- **클럭**

→ 컴퓨터의 모든 부품을 일사불란하게 움직일 수 있게 하는 시간 단위 

CPU의 속도 단위로 간주되기도 한다.

일반적으로 클럭 속도가 높은 CPU는 성능이 좋다.

<br>

- **클럭 속도**

→ 1초에 클럭이 몇 번 반복되는지를 나타내는 단위. 헤르츠 (Hz)로 측정. 

클럭 속도가 높은 CPU가 일반적으로 빠르게 동작

<br>

클럭속도는 일정하지않고 고성능을 요하는 순간에는 순간적으로 클럭 속도를 높이고, 그렇지 않을 때에는 클록속도를 낮추기도 한다.

최대 클럭 속도를 강제로 더 끌어올리는 기법을 오버클럭킹이라고 한다.

클럭속도를 무작정 높이면 발열문제 생긴다.

⇒ 클럭 속도만으로 CPU의 성능을 올리는 것에는 한계가 있다.

<br>
<br>

- **코어**

→ CPU내에서 명령어를 실행하는 **부품** (= 전통적인 CPU → ALU, 제어장치, 레지스터가 들어있는 한 묶음) (전통적인 CPU = 코어)

<ins>**멀티코어 CPU (= 멀티코어 프로세서)**</ins>: 여러 개의 코어를 포함하고 있는 CPU

CPU안에 코어가 몇 개 포함되어있는지에 따라 종류가 나뉨

<br>

CPU의 연산속도가 코어 수에 비례하여 증가하지는 않는다.

코어마다 처리할 연산이 적절히 분배되지 않는다면 코어 수에 비례하여 연산 속도가 증가하지 않는다.

처리하고자 하는 작업량보다 코어 수가 지나치게 많아도 성능에는 크게 영향이 없다

⇒ <ins>코어마다 처리할 명령어들이 얼마나 적절하게 분배하느냐가 중요하고 그에 따라서 연산속도는 크게 달라진다</ins>

<br>
<br>

- **스레드**

→ 실행 흐름의 단위. **명령어를 실행하는 단위**

<br>

- 종류
    - 하드웨어적 스레드 - CPU에서 사용됨
    - 소프트웨어적 스레드 - 프로그램에서 사용됨

<br>

- <ins>하드웨어적 스레드 (= 논리 프로세서)</ins>

→ 하나의 코어가 동시에 처리하는 명령어 단위 (CPU에서 사용하는 스레드)

    - 멀티스레드 프로세서 (= 멀티스레드 CPU)

    → 하나의 코어로 여러 명령어를 동시에 처리하는 CPU

하이퍼스레딩: 인텔의 멀티스레드 기술

<br>

- <ins>소프트웨어적 스레드</ins>

→ 하나의 프로그램에서 독립적으로 실행되는 단위 (프로그래밍 언어나 운영체제를 학습할 때 사용하는 스레드)

하나의 프로그램은 실행되는 과정에서 한 부분만 실행될 수도 있고, 여러 부분이 동시에 실행될 수도 있다.

<br>
<br>

- **멀티스레드 프로세서 (= 멀티스레드 CPU)**

→ 하나의 코어로 여러 명령어를 동시에 처리하는 CPU

명령어 하나에 프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터와 같이 꼭 필요한 레지스터 묶음을 가지고있는 개수만큼 여러 명령어를 동시에 처리 가능하다.

(레지스터 5묶음을 가지고있으면 5개의 명령어 동시처리 가능)

<br>
<br>
<br>

## 명령어 병렬 처리 기법

→ CPU를 한시도 쉬지 않고 작동시키는 기법

<br>

- <ins>종류</ins>
    - 명령어 파이프라이닝
    - 슈퍼스칼라
    - 비순차적 명령어 처리

<br>
<br>

- **명령어 파이프리닝**

→ 동시에 여러 개의 명령어를 겹쳐 실행하는 기법 (효율적, 높은 성능). 단일 파이프라인으로도 구현 가능

<br>

- 명령어 처리 과정 (클럭 단위로 나눔)
    1. 명령어 인출
    2. 명령어 해석
    3. 명령어 실행
    4. 결과 저장

⇒ 같은 단계가 겹치지만 않는다면 CPU는 ‘각 단계를 동시에 실행’할 수 있다.

명령어 처리 과정들을 명령어 파이프 라인처럼 인식하고 동시에 처리하는 기법이 명령어 파이프라이닝이다.

<br>

- <ins>파이프라인 위험 - 특정 상황에서는 성능 향상에 실해하는 경우</ins>
    - 데이터 위험
    - 제어 위험
    - 구조적 위험

<br>

<ins>데이터 위험</ins>

→ 명령어 간 ‘데이터 의존성’에 의해 발생. 

데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 해서 파이프라인이 제대로 작동하지 않는 것

<br>

<ins>제어 위험</ins>

→ 분기등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생

일반적으로 프로그램은 카운터는 ‘현재 실행 중인 명령어의 다음주소’로 갱신. (10번지 명령어 실행중, 다음 명령어 11번지, 12번지~ )

하지만 명령어가 실행되면서 프로그램 카운터 값이 변화가 생겨 명령어 파이프라인에 미리 가지고와서 처리 중이었던 명령어들이 필요가 없어지는 것

ex) 10번지에서 실행 중 60번지로 분기할 경우 11~59번지의 명령어들은 쓸모없어짐.

<br>

분기 예측 - 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술

<br>

<ins>구조적 위험 (= 자원위험)</ins>

→ 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생.

<br>
<br>

- **슈퍼스칼라**

→ CPU내부에 여러 개의 명령어 파이프라인을 두는 기법

<br>

슈퍼스칼라 프로세서(= 슈퍼스칼라 CPU) - 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU

매 클럭 주기마다 동시에 여러 명령어를 인출할 수도, 실행할 수도 있어야함.

파이프라인 개수에 비례하여 프로그램 처리 속도가 빨라지는데 무조건 비례해서 빨라지지는 않는다

여러개의 파이프라인을 사용하면 데이터, 제어, 자원 위험을 피하기 더 까다로워진다.

<br>
<br>

- **비순차적 명령어 처리 기법 (OoOE)**

→ 파이프라인의 중단을 방지하기 위해 명령어를 순차적으로 처리하지 않는 기법.

순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이  멈추는 것을 방지

(대부분의 CPU가 차용하는 기법)

이 기법이 사용가능한 CPU는 어떤 명령어들이 데이터 의존성을 가지고 있는지, 순서를 바꿔 실행할 수 있는 명령어에는 어떤 것들이 있는지를 판단할 수 있어야함

<br>
<br>
<br>

## CISC와 RISC

- **명령어 집합 구조 (= 명령어 집합, ISA)**

→ CPU의 언어이자 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속. (CPU가 이해할 수 있는 명령어들의 모음. 일종의 CPU의 언어)

<br>

명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등이 CPU마다 조금씩 차이가 있기 때문에 즉, CPU마다 ISA가 다를 수 있다.

같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다

ISA가 다르면 CPU하드웨어 설계에도 영향을 미칠만큼 많은것이 달라진다.

<br>
<br>

- **CISC**

→ 복잡하고 다양한 수의 <ins>가변길이 명령어</ins> 집합을 활용 (파이프라이닝에 불리)

다양하고 강력한 기능의 명령어 집합을 활용 ⇒ 따라서 가변 길이 명령어 활용

상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다. → 메모리 공간 절약의 장점

<br>

- 단점
    1. 명령어의 크기, 실행되기까지의 시간이 일정하지 않음.
    2. 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.
    3. 규격화 되지 않은 명령어 → 파이프라이닝을 어렵게 만듬
    4. 대다수의 복잡한 명령어 → 사용빈도 낮음 (사용하는것만 사용)

<br>
<br>

- **RISC**

→ 단순하고 적은 수의 <ins>고정 길이 명령어</ins> 집합을 활용 (파이프라이닝에 유리)

CISC에 비해 명령어의 종류 적고, 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어 지향

메모리 직접 접근 명령어 (load, store) 제한 → 메모리접근 단순화, 최소화 ⇒ CISC보다 주소 지정 방식의 종류가 적은경우 많음.

레지스터 적극적 활용 (CISC보다 레지스터를 이용하는 연산 많고, 범용 레지스터 개수도 많다.)

많은 명령으로 프로그램 작동

<br>

| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭에 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행 |
| 파이프라이닝하기 어려움 | 파이프라이닝하기 쉬움 |