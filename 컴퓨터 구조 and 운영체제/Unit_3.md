# 3단원 - 명령어

## 소스 코드와 명령어

<ins>고급언어</ins> - 프로그램을 만들 때 컴퓨터가 이해하는 언어가 아닌 사람이 이해하고 작성하기 쉽게 만들어진 언어. ‘사람을 위한 언어’ (ex. C, C++, Java, Python등)

↔ <ins>저급 언어</ins> - 컴퓨터가 직접 이해하고 실행 할 수 있는 언어. ‘명령어로 이루어진 언어’ (

ex. 기계어, 어셈블리어)

<br>

- **기계어**

→ 0과 1의 명령어 비트로 이루어진 언어

가독성을 위해 16진수로 표현하기도 한다.

<br>

- **어셈블리어**

→ 기계어를 읽기 편한 형태로 번역한 언어

임베디드 개발자, 게임 개발자, 정보보안 분야에서 중요함

컴퓨터가 프로그램을 어떤 과정으로 실행하는지, 프로그램이 어떤 절차로 작동하는지 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있기 때문

<br>
<br>

- 고급언어를 저급언어로 변환할 때 사용 방식

컴파일 - 소스코드 전체가 저급언어로 변환되는 과정

인터프리트 - 소스 코드를 한줄씩 차례로 실행

<br>

- **컴파일 언어**

→ 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어

목적코드 - 컴파일러를 통해 저급 언어로 변환된 코드

<br>

- **인터프리터 언어**

→ 인터프리터에 의해 소스 코드를 한 줄씩 저급 언어로 변환하여 실행하는 고급 언어

| 인터프리터 | 컴파일러 |
| --- | --- |
| 컴퓨터와 대화하듯 한 줄씩 실행 | 소스 코드 전체를 저급 언어로 변환하여 실행 |
| N번째 줄에 문법오류가 있어도 N-1번째까지는 올바르게 수행 | 코드 내에 오류가 하나라도 있으면 컴파일 불가능 |
| 대표언어: Python | 대표언어: C |

일반적으로 인터프리터 언어가 컴파일 언어보다 느림

<br>

+) 링킹

실행코드로 이루어진 파일. 윈도우의 .exe확장자 → 실행파일

목적코드가 있다고해서 바로 실행 불가능

⇒ main 목적코드 안에 실행해야하는 외부 기능들을 main과 연결짓는 작업

<br>
<br>
<br>

## 명령어의 구조

- **명령어**

→ 연산 코드와 오퍼랜드로 구성. (무엇을 대상으로, 어떤 작동을 수행하는지)

연산 코드 (연산자): 명령어가 수행할 연산

오퍼랜드 (피연산자): 연산에 사용할 데이터 혹은 저장된 위치

연산 코드 필드, 오퍼랜드 필드

| 연산코드 | 오퍼랜드 |
| --- | --- |

<br>

- **오퍼랜드**

→ 연산에 사용할 숫자, 문자 등을 나타내는 데이터 or 데이터가 저장된 위치 의미

<ins>오퍼랜드 필드 (주소 필드)</ins> - 메모리 주소나 레지스터 이름 (연산에 사용할 데이터가 저장된 위치)이 담김

<br>

오퍼랜드는 명령어 안에 없을 수도 있고 1개 내지 여러 개가 있을 수도있다.

오퍼랜드의 개수에 따라 명령어를 가르키는 이름이 달라짐

0- 주소 명령어: 오퍼랜드 0개 (없음)

1- 주소 명령어: 오퍼랜드 1개

2- 주소 명령어: 오퍼랜드 2개

<br>

- **연산 코드**

→ 수행할 연산 의미

- 연산 코드 유형
    1. 데이터 전송 (MOVE, STORE, LOAD(FETCH), PUSH, POP)
    2. 산술/논리 연산 (ADD/SUBTRACT/MULTIPLY/DIVIDE,INCREMENT …)
    3. 제어 흐름 변경 (JUMP, HALT, CALL, RETURN)
    4. 입출력 제어 (READ(INPUT), WRITE(OUTPUT), START IO, TEST IO)

    <br>
    <br>

- **주소 지정 방식**

→ 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법 (유효주소를 찾는 방법)

오퍼랜드 필드에 주소를 저장하면 표현(저장)할 수 있는 데이터의 크기가 증가한다.

유효 주소 - 연산의 대상이 되는 데이터가 저장된 위치

<br>

- <ins>즉시 주소 지정 방식</ins>

→ 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식

가장 간단한 형태의 주소 지정 방식

타 주소 지정방식들 보다 빠름 (주소를 통해 데이터를 찾는 과정이 없어졌기 때문)

단점 - 표현할 수 있는 데이터의 크기가 작아짐

<br>

- <ins>직접 주소 지정 방식</ins>

→ 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식

오퍼랜드 필드에서 표현할 수 있는 데이터의 크기가 즉시 주소 지정 방식보다 큼

단점 - 유효 주소를 표현할 수 있는 범위에 제한이 생길 수 있음

<br>

- <ins>간접 주소 지정 방식</ins>

→ 유효 주소의 주소를 오퍼랜스 필드에 명시

직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 증가

단점 - 두 번의 메모리 접근이 필요 ⇒ 느린방식

<br>

- <ins>레지스터 주소 지정 방식</ins>

→ 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜스 필드에 직접 명시

직접 주소 지정 방식과 비슷.

CPU 내부에 있는 레지스터에 접근하는 것이 더 빨라 레지스터 주소 지정 방식은 직접 주소 지정 방식보다 빠르게 데이터 접근 가능

단점 - 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음

<br>

- <ins>레지스터 간접 주소 지정 방식</ins>

→ 연산에 사용할 데이터를 메모리에 저장, 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시

간접 주소 지정 방식과 비슷. but 메모리에 접근하는 횟수 한 번으로 줄어듬

간접 주소 지정 방식보다 빠르다